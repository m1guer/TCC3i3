{"ast":null,"code":"import { Children as $iqq3r$Children, cloneElement as $iqq3r$cloneElement, useState as $iqq3r$useState, useRef as $iqq3r$useRef, useEffect as $iqq3r$useEffect, useCallback as $iqq3r$useCallback, useReducer as $iqq3r$useReducer } from \"react\";\nimport { flushSync as $iqq3r$flushSync } from \"react-dom\";\nimport { useComposedRefs as $iqq3r$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useLayoutEffect as $iqq3r$useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\n\nfunction $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {\n  return $iqq3r$useReducer((state, event) => {\n    const nextState = machine[state][event];\n    return nextState !== null && nextState !== void 0 ? nextState : state;\n  }, initialState);\n}\n\nconst $921a889cee6df7e8$export$99c2b779aa4e8b8b = props => {\n  const {\n    present: present,\n    children: children\n  } = props;\n  const presence = $921a889cee6df7e8$var$usePresence(present);\n  const child = typeof children === 'function' ? children({\n    present: presence.isPresent\n  }) : $iqq3r$Children.only(children);\n  const ref = $iqq3r$useComposedRefs(presence.ref, child.ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? /*#__PURE__*/$iqq3r$cloneElement(child, {\n    ref: ref\n  }) : null;\n};\n\n$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = 'Presence';\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction $921a889cee6df7e8$var$usePresence(present) {\n  const [node1, setNode] = $iqq3r$useState();\n  const stylesRef = $iqq3r$useRef({});\n  const prevPresentRef = $iqq3r$useRef(present);\n  const prevAnimationNameRef = $iqq3r$useRef('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended'\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted'\n    },\n    unmounted: {\n      MOUNT: 'mounted'\n    }\n  });\n  $iqq3r$useEffect(() => {\n    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n  $iqq3r$useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);\n      if (present) send('MOUNT');else if (currentAnimationName === 'none' || (styles === null || styles === void 0 ? void 0 : styles.display) === 'none') // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');else {\n        /**\n        * When `present` changes to `false`, we check changes to animation-name to\n        * determine whether an animation has started. We chose this approach (reading\n        * computed styles) because there is no `animationrun` event and `animationstart`\n        * fires after `animation-delay` has expired which would be too late.\n        */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n        if (wasPresent && isAnimating) send('ANIMATION_OUT');else send('UNMOUNT');\n      }\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n  $iqq3r$useLayoutEffect(() => {\n    if (node1) {\n      /**\n      * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n      * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n      * make sure we only trigger ANIMATION_END for the currently active animation.\n      */\n      const handleAnimationEnd = event => {\n        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node1 && isCurrentAnimation) // With React 18 concurrency this update is applied\n          // a frame after the animation ends, creating a flash of visible content.\n          // By manually flushing we ensure they sync within a frame, removing the flash.\n          $iqq3r$flushSync(() => send('ANIMATION_END'));\n      };\n\n      const handleAnimationStart = event => {\n        if (event.target === node1) // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);\n      };\n\n      node1.addEventListener('animationstart', handleAnimationStart);\n      node1.addEventListener('animationcancel', handleAnimationEnd);\n      node1.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node1.removeEventListener('animationstart', handleAnimationStart);\n        node1.removeEventListener('animationcancel', handleAnimationEnd);\n        node1.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n  }, [node1, send]);\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: $iqq3r$useCallback(node => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, [])\n  };\n}\n/* -----------------------------------------------------------------------------------------------*/\n\n\nfunction $921a889cee6df7e8$var$getAnimationName(styles) {\n  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || 'none';\n}\n\nexport { $921a889cee6df7e8$export$99c2b779aa4e8b8b as Presence };","map":{"version":3,"sources":["packages/react/presence/src/index.ts","packages/react/presence/src/Presence.tsx","packages/react/presence/src/useStateMachine.tsx"],"names":["Presence","props","presence","usePresence","child","children","present","React","ref","useComposedRefs","forceMount","stylesRef","prevPresentRef","prevAnimationNameRef","initialState","useStateMachine","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","currentAnimationName","getAnimationName","state","useLayoutEffect","styles","wasPresent","hasPresentChanged","prevAnimationName","send","isAnimating","handleAnimationEnd","event","isCurrentAnimation","ReactDOM","handleAnimationStart","node","isPresent","getComputedStyle","setNode","nextState","machine"],"mappings":"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","sourcesContent":["export { Presence } from './Presence';\nexport type { PresenceProps } from './Presence';\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement;\n\n  const ref = useComposedRefs(presence.ref, (child as any).ref);\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied\n          // a frame after the animation ends, creating a flash of visible content.\n          // By manually flushing we ensure they sync within a frame, removing the flash.\n          ReactDOM.flushSync(() => send('ANIMATION_END'));\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// ðŸ¤¯ https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}