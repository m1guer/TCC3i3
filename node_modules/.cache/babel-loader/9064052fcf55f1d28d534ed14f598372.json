{"ast":null,"code":"function groupOptions({\n  data\n}) {\n  const sortedData = [];\n  const unGroupedData = [];\n  const groupedData = data.reduce((acc, item, index) => {\n    if (item.group) {\n      if (acc[item.group]) acc[item.group].push(index);else acc[item.group] = [index];\n    } else {\n      unGroupedData.push(index);\n    }\n\n    return acc;\n  }, {});\n  Object.keys(groupedData).forEach(groupName => {\n    sortedData.push(...groupedData[groupName].map(index => data[index]));\n  });\n  sortedData.push(...unGroupedData.map(itemIndex => data[itemIndex]));\n  return sortedData;\n}\n\nfunction getGroupedOptions(data) {\n  const sorted = groupOptions({\n    data\n  });\n  const unGrouped = [];\n  const grouped = [];\n  let groupName = null;\n  sorted.forEach((item, index) => {\n    if (!item.group) {\n      unGrouped.push({\n        type: \"item\",\n        item,\n        index\n      });\n    } else {\n      if (groupName !== item.group) {\n        groupName = item.group;\n        grouped.push({\n          type: \"label\",\n          label: groupName\n        });\n      }\n\n      grouped.push({\n        type: \"item\",\n        item,\n        index\n      });\n    }\n  });\n  return {\n    grouped,\n    unGrouped,\n    items: [...grouped, ...unGrouped],\n    hasItems: grouped.length > 0 || unGrouped.length > 0\n  };\n}\n\nexport { getGroupedOptions, groupOptions };","map":{"version":3,"sources":["../../src/group-options/group-options.ts"],"names":[],"mappings":"AAAO,SAAS,YAAT,CAAsB;AAAE,EAAA;AAAF,CAAtB,EAAgC;AACrC,QAAM,UAAU,GAAG,EAAnB;AACA,QAAM,aAAa,GAAG,EAAtB;AACA,QAAM,WAAW,GAAG,IAAI,CAAC,MAAL,CAAY,CAAC,GAAD,EAAM,IAAN,EAAY,KAAZ,KAAsB;AACpD,QAAI,IAAI,CAAC,KAAT,EAAgB;AACd,UAAI,GAAG,CAAC,IAAI,CAAC,KAAN,CAAP,EACE,GAAG,CAAC,IAAI,CAAC,KAAN,CAAH,CAAgB,IAAhB,CAAqB,KAArB,EADF,KAGE,GAAG,CAAC,IAAI,CAAC,KAAN,CAAH,GAAkB,CAAC,KAAD,CAAlB;AACH,KALD,MAKO;AACL,MAAA,aAAa,CAAC,IAAd,CAAmB,KAAnB;AACD;;AACD,WAAO,GAAP;AACD,GAVmB,EAUjB,EAViB,CAApB;AAWA,EAAA,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,OAAzB,CAAkC,SAAD,IAAe;AAC9C,IAAA,UAAU,CAAC,IAAX,CAAgB,GAAG,WAAW,CAAC,SAAD,CAAX,CAAuB,GAAvB,CAA4B,KAAD,IAAW,IAAI,CAAC,KAAD,CAA1C,CAAnB;AACD,GAFD;AAGA,EAAA,UAAU,CAAC,IAAX,CAAgB,GAAG,aAAa,CAAC,GAAd,CAAmB,SAAD,IAAe,IAAI,CAAC,SAAD,CAArC,CAAnB;AACA,SAAO,UAAP;AACD;;AACM,SAAS,iBAAT,CAA2B,IAA3B,EAAiC;AACtC,QAAM,MAAM,GAAG,YAAY,CAAC;AAAE,IAAA;AAAF,GAAD,CAA3B;AACA,QAAM,SAAS,GAAG,EAAlB;AACA,QAAM,OAAO,GAAG,EAAhB;AACA,MAAI,SAAS,GAAG,IAAhB;AACA,EAAA,MAAM,CAAC,OAAP,CAAe,CAAC,IAAD,EAAO,KAAP,KAAiB;AAC9B,QAAI,CAAC,IAAI,CAAC,KAAV,EAAiB;AACf,MAAA,SAAS,CAAC,IAAV,CAAe;AAAE,QAAA,IAAI,EAAE,MAAR;AAAgB,QAAA,IAAhB;AAAsB,QAAA;AAAtB,OAAf;AACD,KAFD,MAEO;AACL,UAAI,SAAS,KAAK,IAAI,CAAC,KAAvB,EAA8B;AAC5B,QAAA,SAAS,GAAG,IAAI,CAAC,KAAjB;AACA,QAAA,OAAO,CAAC,IAAR,CAAa;AAAE,UAAA,IAAI,EAAE,OAAR;AAAiB,UAAA,KAAK,EAAE;AAAxB,SAAb;AACD;;AACD,MAAA,OAAO,CAAC,IAAR,CAAa;AAAE,QAAA,IAAI,EAAE,MAAR;AAAgB,QAAA,IAAhB;AAAsB,QAAA;AAAtB,OAAb;AACD;AACF,GAVD;AAWA,SAAO;AACL,IAAA,OADK;AAEL,IAAA,SAFK;AAGL,IAAA,KAAK,EAAE,CAAC,GAAG,OAAJ,EAAa,GAAG,SAAhB,CAHF;AAIL,IAAA,QAAQ,EAAE,OAAO,CAAC,MAAR,GAAiB,CAAjB,IAAsB,SAAS,CAAC,MAAV,GAAmB;AAJ9C,GAAP;AAMF","sourcesContent":["interface GroupData {\n  data: { group?: string }[];\n}\n\nexport function groupOptions({ data }: GroupData) {\n  const sortedData = [];\n  const unGroupedData = [];\n  const groupedData = data.reduce((acc, item, index) => {\n    if (item.group) {\n      if (acc[item.group]) acc[item.group].push(index);\n      else acc[item.group] = [index];\n    } else {\n      unGroupedData.push(index);\n    }\n    return acc;\n  }, {});\n\n  Object.keys(groupedData).forEach((groupName) => {\n    sortedData.push(...groupedData[groupName].map((index) => data[index]));\n  });\n\n  sortedData.push(...unGroupedData.map((itemIndex) => data[itemIndex]));\n\n  return sortedData;\n}\n\nexport function getGroupedOptions<T extends any[]>(data: T) {\n  type Item = { type: 'item'; item: T[number]; index: number };\n  type Label = { type: 'label'; label: string };\n\n  const sorted = groupOptions({ data });\n  const unGrouped: Item[] = [];\n  const grouped: (Item | Label)[] = [];\n  let groupName = null;\n\n  sorted.forEach((item, index) => {\n    if (!item.group) {\n      unGrouped.push({ type: 'item', item, index });\n    } else {\n      if (groupName !== item.group) {\n        groupName = item.group;\n        grouped.push({ type: 'label', label: groupName });\n      }\n      grouped.push({ type: 'item', item, index });\n    }\n  });\n\n  return {\n    grouped,\n    unGrouped,\n    items: [...grouped, ...unGrouped],\n    hasItems: grouped.length > 0 || unGrouped.length > 0,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}