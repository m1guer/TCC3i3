{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nimport { useReducedMotion } from '../use-reduced-motion/use-reduced-motion.js';\nimport { useWindowEvent } from '../use-window-event/use-window-event.js';\nimport { easeInOutQuad } from './utils/ease-in-out-quad.js';\nimport { getRelativePosition } from './utils/get-relative-position.js';\nimport { getScrollStart } from './utils/get-scroll-start.js';\nimport { setScrollParam } from './utils/set-scroll-param.js';\n\nfunction useScrollIntoView({\n  duration = 1250,\n  axis = \"y\",\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false\n} = {}) {\n  const frameID = useRef(0);\n  const startTime = useRef(0);\n  const shouldStop = useRef(false);\n  const scrollableRef = useRef(null);\n  const targetRef = useRef(null);\n  const reducedMotion = useReducedMotion();\n\n  const cancel = () => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n\n  const scrollIntoView = useCallback(({\n    alignment = \"start\"\n  } = {}) => {\n    var _a;\n\n    shouldStop.current = false;\n\n    if (frameID.current) {\n      cancel();\n    }\n\n    const start = (_a = getScrollStart({\n      parent: scrollableRef.current,\n      axis\n    })) != null ? _a : 0;\n    const change = getRelativePosition({\n      parent: scrollableRef.current,\n      target: targetRef.current,\n      axis,\n      alignment,\n      offset,\n      isList\n    }) - (scrollableRef.current ? 0 : start);\n\n    function animateScroll() {\n      if (startTime.current === 0) {\n        startTime.current = performance.now();\n      }\n\n      const now = performance.now();\n      const elapsed = now - startTime.current;\n      const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n      const distance = start + change * easing(t);\n      setScrollParam({\n        parent: scrollableRef.current,\n        axis,\n        distance\n      });\n\n      if (!shouldStop.current && t < 1) {\n        frameID.current = requestAnimationFrame(animateScroll);\n      } else {\n        typeof onScrollFinish === \"function\" && onScrollFinish();\n        startTime.current = 0;\n        frameID.current = 0;\n        cancel();\n      }\n    }\n\n    animateScroll();\n  }, [scrollableRef.current]);\n\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n\n  useWindowEvent(\"wheel\", handleStop, {\n    passive: true\n  });\n  useWindowEvent(\"touchmove\", handleStop, {\n    passive: true\n  });\n  useEffect(() => cancel, []);\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel\n  };\n}\n\nexport { useScrollIntoView };","map":{"version":3,"sources":["../../src/use-scroll-into-view/use-scroll-into-view.ts"],"names":[],"mappings":"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","sourcesContent":["import { useCallback, useRef, useEffect } from 'react';\nimport { useReducedMotion } from '../use-reduced-motion/use-reduced-motion';\nimport { useWindowEvent } from '../use-window-event/use-window-event';\nimport { easeInOutQuad } from './utils/ease-in-out-quad';\nimport { getRelativePosition } from './utils/get-relative-position';\nimport { getScrollStart } from './utils/get-scroll-start';\nimport { setScrollParam } from './utils/set-scroll-param';\n\ninterface ScrollIntoViewAnimation {\n  /** target element alignment relatively to parent based on current axis */\n  alignment?: 'start' | 'end' | 'center';\n}\n\ninterface ScrollIntoViewParams {\n  /** callback fired after scroll */\n  onScrollFinish?: () => void;\n\n  /** duration of scroll in milliseconds */\n  duration?: number;\n\n  /** axis of scroll */\n  axis?: 'x' | 'y';\n\n  /** custom mathematical easing function */\n  easing?: (t: number) => number;\n\n  /** additional distance between nearest edge and element */\n  offset?: number;\n\n  /** indicator if animation may be interrupted by user scrolling */\n  cancelable?: boolean;\n\n  /** prevents content jumping in scrolling lists with multiple targets */\n  isList?: boolean;\n}\n\nexport function useScrollIntoView<\n  Target extends HTMLElement,\n  Parent extends HTMLElement | null = null\n>({\n  duration = 1250,\n  axis = 'y',\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false,\n}: ScrollIntoViewParams = {}) {\n  const frameID = useRef(0);\n  const startTime = useRef(0);\n  const shouldStop = useRef(false);\n\n  const scrollableRef = useRef<Parent>(null);\n  const targetRef = useRef<Target>(null);\n\n  const reducedMotion = useReducedMotion();\n\n  const cancel = (): void => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n\n  const scrollIntoView = useCallback(\n    ({ alignment = 'start' }: ScrollIntoViewAnimation = {}) => {\n      shouldStop.current = false;\n\n      if (frameID.current) {\n        cancel();\n      }\n\n      const start = getScrollStart({ parent: scrollableRef.current, axis }) ?? 0;\n\n      const change =\n        getRelativePosition({\n          parent: scrollableRef.current,\n          target: targetRef.current,\n          axis,\n          alignment,\n          offset,\n          isList,\n        }) - (scrollableRef.current ? 0 : start);\n\n      function animateScroll() {\n        if (startTime.current === 0) {\n          startTime.current = performance.now();\n        }\n\n        const now = performance.now();\n        const elapsed = now - startTime.current;\n\n        // easing timing progress\n        const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n\n        const distance = start + change * easing(t);\n\n        setScrollParam({\n          parent: scrollableRef.current,\n          axis,\n          distance,\n        });\n\n        if (!shouldStop.current && t < 1) {\n          frameID.current = requestAnimationFrame(animateScroll);\n        } else {\n          typeof onScrollFinish === 'function' && onScrollFinish();\n          startTime.current = 0;\n          frameID.current = 0;\n          cancel();\n        }\n      }\n      animateScroll();\n    },\n    [scrollableRef.current]\n  );\n\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n\n  /**\n   * detection of one of these events stops scroll animation\n   * wheel - mouse wheel / touch pad\n   * touchmove - any touchable device\n   */\n\n  useWindowEvent('wheel', handleStop, {\n    passive: true,\n  });\n\n  useWindowEvent('touchmove', handleStop, {\n    passive: true,\n  });\n\n  // cleanup requestAnimationFrame\n  useEffect(() => cancel, []);\n\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}