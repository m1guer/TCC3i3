{"ast":null,"code":"const TABBABLE_NODES = /input|select|textarea|button|object/;\nconst FOCUS_SELECTOR = \"a, input, select, textarea, button, object, [tabindex]\";\n\nfunction hidden(element) {\n  if (process.env.NODE_ENV === \"test\") {\n    return false;\n  }\n\n  return element.style.display === \"none\";\n}\n\nfunction visible(element) {\n  const isHidden = element.getAttribute(\"aria-hidden\") || element.getAttribute(\"hidden\") || element.getAttribute(\"type\") === \"hidden\";\n\n  if (isHidden) {\n    return false;\n  }\n\n  let parentElement = element;\n\n  while (parentElement) {\n    if (parentElement === document.body) {\n      break;\n    }\n\n    if (hidden(parentElement)) {\n      return false;\n    }\n\n    parentElement = parentElement.parentNode;\n  }\n\n  return true;\n}\n\nfunction getElementTabIndex(element) {\n  let tabIndex = element.getAttribute(\"tabindex\");\n\n  if (tabIndex === null) {\n    tabIndex = void 0;\n  }\n\n  return parseInt(tabIndex, 10);\n}\n\nfunction focusable(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));\n  const res = TABBABLE_NODES.test(nodeName) && !element.disabled || (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n  return res && visible(element);\n}\n\nfunction tabbable(element) {\n  const tabIndex = getElementTabIndex(element);\n  const isTabIndexNaN = Number.isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element);\n}\n\nfunction findTabbableDescendants(element) {\n  return Array.from(element.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);\n}\n\nexport { FOCUS_SELECTOR, findTabbableDescendants, focusable, tabbable };","map":{"version":3,"sources":["../../src/use-focus-trap/tabbable.ts"],"names":[],"mappings":"AAAA,MAAM,cAAc,GAAG,qCAAvB;AACY,MAAC,cAAc,GAAG,wDAAlB;;AACZ,SAAS,MAAT,CAAgB,OAAhB,EAAyB;AACvB,MAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,MAA7B,EAAqC;AACnC,WAAO,KAAP;AACD;;AACD,SAAO,OAAO,CAAC,KAAR,CAAc,OAAd,KAA0B,MAAjC;AACD;;AACD,SAAS,OAAT,CAAiB,OAAjB,EAA0B;AACxB,QAAM,QAAQ,GAAG,OAAO,CAAC,YAAR,CAAqB,aAArB,KAAuC,OAAO,CAAC,YAAR,CAAqB,QAArB,CAAvC,IAAyE,OAAO,CAAC,YAAR,CAAqB,MAArB,MAAiC,QAA3H;;AACA,MAAI,QAAJ,EAAc;AACZ,WAAO,KAAP;AACD;;AACD,MAAI,aAAa,GAAG,OAApB;;AACA,SAAO,aAAP,EAAsB;AACpB,QAAI,aAAa,KAAK,QAAQ,CAAC,IAA/B,EAAqC;AACnC;AACD;;AACD,QAAI,MAAM,CAAC,aAAD,CAAV,EAA2B;AACzB,aAAO,KAAP;AACD;;AACD,IAAA,aAAa,GAAG,aAAa,CAAC,UAA9B;AACD;;AACD,SAAO,IAAP;AACD;;AACD,SAAS,kBAAT,CAA4B,OAA5B,EAAqC;AACnC,MAAI,QAAQ,GAAG,OAAO,CAAC,YAAR,CAAqB,UAArB,CAAf;;AACA,MAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,IAAA,QAAQ,GAAG,KAAK,CAAhB;AACD;;AACD,SAAO,QAAQ,CAAC,QAAD,EAAW,EAAX,CAAf;AACD;;AACM,SAAS,SAAT,CAAmB,OAAnB,EAA4B;AACjC,QAAM,QAAQ,GAAG,OAAO,CAAC,QAAR,CAAiB,WAAjB,EAAjB;AACA,QAAM,gBAAgB,GAAG,CAAC,MAAM,CAAC,KAAP,CAAa,kBAAkB,CAAC,OAAD,CAA/B,CAA1B;AACA,QAAM,GAAG,GAAG,cAAc,CAAC,IAAf,CAAoB,QAApB,KAAiC,CAAC,OAAO,CAAC,QAA1C,KAAuD,OAAO,YAAY,iBAAnB,GAAuC,OAAO,CAAC,IAAR,IAAgB,gBAAvD,GAA0E,gBAAjI,CAAZ;AACA,SAAO,GAAG,IAAI,OAAO,CAAC,OAAD,CAArB;AACD;;AACM,SAAS,QAAT,CAAkB,OAAlB,EAA2B;AAChC,QAAM,QAAQ,GAAG,kBAAkB,CAAC,OAAD,CAAnC;AACA,QAAM,aAAa,GAAG,MAAM,CAAC,KAAP,CAAa,QAAb,CAAtB;AACA,SAAO,CAAC,aAAa,IAAI,QAAQ,IAAI,CAA9B,KAAoC,SAAS,CAAC,OAAD,CAApD;AACD;;AACM,SAAS,uBAAT,CAAiC,OAAjC,EAA0C;AAC/C,SAAO,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,gBAAR,CAAyB,cAAzB,CAAX,EAAqD,MAArD,CAA4D,QAA5D,CAAP;AACF","sourcesContent":["const TABBABLE_NODES = /input|select|textarea|button|object/;\nexport const FOCUS_SELECTOR = 'a, input, select, textarea, button, object, [tabindex]';\n\nfunction hidden(element: HTMLElement) {\n  if (process.env.NODE_ENV === 'test') {\n    return false;\n  }\n\n  return element.style.display === 'none';\n}\n\nfunction visible(element: HTMLElement) {\n  const isHidden =\n    element.getAttribute('aria-hidden') ||\n    element.getAttribute('hidden') ||\n    element.getAttribute('type') === 'hidden';\n\n  if (isHidden) {\n    return false;\n  }\n\n  let parentElement: HTMLElement = element;\n  while (parentElement) {\n    if (parentElement === document.body) {\n      break;\n    }\n\n    if (hidden(parentElement)) {\n      return false;\n    }\n\n    parentElement = parentElement.parentNode as HTMLElement;\n  }\n\n  return true;\n}\n\nfunction getElementTabIndex(element: HTMLElement) {\n  let tabIndex = element.getAttribute('tabindex');\n  if (tabIndex === null) {\n    tabIndex = undefined;\n  }\n  return parseInt(tabIndex, 10);\n}\n\nexport function focusable(element: HTMLElement) {\n  const nodeName = element.nodeName.toLowerCase();\n  const isTabIndexNotNaN = !Number.isNaN(getElementTabIndex(element));\n  const res =\n    // @ts-ignore\n    (TABBABLE_NODES.test(nodeName) && !element.disabled) ||\n    (element instanceof HTMLAnchorElement ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n\n  return res && visible(element);\n}\n\nexport function tabbable(element: HTMLElement) {\n  const tabIndex = getElementTabIndex(element);\n  const isTabIndexNaN = Number.isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element);\n}\n\nexport function findTabbableDescendants(element: HTMLElement): HTMLElement[] {\n  return Array.from(element.querySelectorAll<HTMLElement>(FOCUS_SELECTOR)).filter(tabbable);\n}\n"]},"metadata":{},"sourceType":"module"}